{% extends 'base_tailwind.html' %}

{% block title %}Branch Transfer Analysis - Eclipse{% endblock %}

{% block content %}
<div x-data="branchAnalysis()" x-init="init()" class="max-w-7xl mx-auto">
    <!-- Header -->
    <div class="mb-8">
        <h1 class="text-3xl font-bold text-white mb-2">Branch Transfer Analysis</h1>
        <p class="text-gray-400">Analyze branch-to-branch transfers by buyline from CSV data</p>
    </div>

    <!-- File Upload Section -->
    <div x-show="!dataLoaded && !previewLoaded" class="mb-8">
        <div
            @drop.prevent="handleDrop($event)"
            @dragover.prevent="dragOver = true"
            @dragleave.prevent="dragOver = false"
            :class="{'border-blue-500 bg-blue-500/10': dragOver}"
            class="border-2 border-dashed border-gray-600 rounded-lg p-12 text-center transition-all"
        >
            <svg class="w-16 h-16 mx-auto mb-4 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
            </svg>
            <p class="text-lg text-white mb-2">Drop your CSV file here</p>
            <p class="text-sm text-gray-400 mb-4">or click to browse</p>
            <input
                type="file"
                @change="handleFileSelect($event)"
                accept=".csv"
                class="hidden"
                x-ref="fileInput"
            >
            <button
                @click="$refs.fileInput.click()"
                class="px-6 py-3 bg-gradient-to-r from-blue-600 to-purple-600 text-white rounded-lg hover:from-blue-700 hover:to-purple-700 transition-all font-semibold"
            >
                Select CSV File
            </button>

            <template x-if="processing">
                <div class="mt-6">
                    <div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
                    <p class="text-gray-400 mt-2">Loading preview...</p>
                </div>
            </template>
        </div>
    </div>

    <!-- Preview & Header Row Selection -->
    <div x-show="previewLoaded && !dataLoaded" class="mb-8">
        <div class="bg-gray-800/50 border border-gray-700/50 rounded-lg p-6">
            <h3 class="text-xl font-semibold text-white mb-4">Step 2: Select Header Row</h3>
            <p class="text-gray-400 mb-4">Review the preview below and select which row contains the column headers (BUYLINE, XFER_FROM_BR, XFER_TO_BR).</p>

            <div class="mb-4 flex items-center gap-4">
                <label class="text-sm text-gray-400">Header row:</label>
                <select
                    x-model.number="headerRow"
                    class="px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                >
                    <template x-for="i in Math.min(20, filePreview.length)" :key="i">
                        <option :value="i" x-text="'Row ' + i"></option>
                    </template>
                </select>
                <span class="text-xs text-gray-500">First <span x-text="Math.min(10, filePreview.length)"></span> rows shown</span>
            </div>

            <!-- Preview Table -->
            <div class="overflow-x-auto mb-4">
                <table class="min-w-full text-sm text-gray-300">
                    <tbody>
                        <template x-for="(row, rowIndex) in filePreview.slice(0, 10)" :key="rowIndex">
                            <tr :class="{'bg-blue-600/20 border-l-4 border-blue-500': headerRow === rowIndex + 1, 'hover:bg-gray-700/30': headerRow !== rowIndex + 1}">
                                <td class="px-3 py-2 font-mono text-xs text-gray-500" x-text="rowIndex + 1"></td>
                                <template x-for="(cell, cellIndex) in row.slice(0, 10)" :key="cellIndex">
                                    <td class="px-3 py-2 border-l border-gray-700" x-text="cell || '(empty)'"></td>
                                </template>
                            </tr>
                        </template>
                    </tbody>
                </table>
            </div>

            <div class="flex justify-between">
                <button
                    @click="cancelPreview()"
                    class="px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white rounded-md transition-colors"
                >
                    Cancel
                </button>
                <button
                    @click="processWithHeaderRow()"
                    class="px-6 py-3 bg-gradient-to-r from-blue-600 to-purple-600 text-white rounded-lg hover:from-blue-700 hover:to-purple-700 transition-all font-semibold"
                >
                    Process Data
                </button>
            </div>
        </div>
    </div>

    <!-- Main Analysis View -->
    <div x-show="dataLoaded">
        <!-- Action Bar -->
        <div class="flex justify-between items-center mb-6">
            <div class="text-sm text-gray-400">
                <span x-text="rawData.length"></span> total transfers |
                <span x-text="Object.keys(buylineData).length"></span> buylines
            </div>
            <div class="flex gap-3">
                <button
                    @click="downloadCSV()"
                    class="px-4 py-2 bg-green-600 hover:bg-green-700 text-white rounded-md transition-colors flex items-center gap-2"
                >
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
                    </svg>
                    Download CSV
                </button>
                <button
                    @click="downloadExcel()"
                    class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-md transition-colors flex items-center gap-2"
                >
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                    </svg>
                    Download Excel
                </button>
                <button
                    @click="resetData()"
                    class="px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white rounded-md transition-colors"
                >
                    Upload New File
                </button>
            </div>
        </div>

        <!-- Tab Navigation -->
        <div class="mb-6">
            <div class="border-b border-gray-700">
                <nav class="-mb-px flex space-x-8">
                    <button
                        @click="activeTab = 'overview'"
                        :class="activeTab === 'overview' ? 'border-blue-500 text-blue-400' : 'border-transparent text-gray-400 hover:text-gray-300 hover:border-gray-300'"
                        class="whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm transition-colors flex items-center gap-2"
                    >
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
                        </svg>
                        Overview
                    </button>
                    <button
                        @click="activeTab = 'map'"
                        :class="activeTab === 'map' ? 'border-blue-500 text-blue-400' : 'border-transparent text-gray-400 hover:text-gray-300 hover:border-gray-300'"
                        class="whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm transition-colors flex items-center gap-2"
                    >
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7"></path>
                        </svg>
                        Route Map
                    </button>
                    <button
                        @click="activeTab = 'details'"
                        :class="activeTab === 'details' ? 'border-blue-500 text-blue-400' : 'border-transparent text-gray-400 hover:text-gray-300 hover:border-gray-300'"
                        class="whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm transition-colors flex items-center gap-2"
                    >
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h18M3 14h18m-9-4v8m-7 0h14a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                        </svg>
                        Details
                    </button>
                </nav>
            </div>
        </div>

        <!-- Overview Tab -->
        <div x-show="activeTab === 'overview'">
            <!-- Visualizations -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
            <!-- Top Routes Chart -->
            <div class="bg-gray-800/50 border border-gray-700/50 rounded-lg p-6">
                <h3 class="text-lg font-bold text-white mb-4">Top 10 Transfer Routes</h3>
                <canvas x-ref="topRoutesChart"></canvas>
            </div>

            <!-- Buyline Distribution Chart -->
            <div class="bg-gray-800/50 border border-gray-700/50 rounded-lg p-6">
                <h3 class="text-lg font-bold text-white mb-4">Transfer Count by Buyline</h3>
                <canvas x-ref="buylineChart"></canvas>
            </div>
        </div>

        <!-- Summary by Buyline -->
        <div class="bg-gray-800/50 border border-gray-700/50 rounded-lg p-6 mb-6">
            <h2 class="text-xl font-bold text-white mb-4">Summary by Buyline</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                <template x-for="(data, buyline) in buylineData" :key="buyline">
                    <div class="bg-gray-900/50 rounded-lg p-4 border border-gray-700 cursor-pointer hover:border-blue-500 transition-colors" @click="expandBuyline(buyline)">
                        <div class="flex justify-between items-start mb-3">
                            <h3 class="text-lg font-semibold text-white" x-text="buyline"></h3>
                            <span class="px-2 py-1 bg-blue-600/20 border border-blue-500/30 text-blue-300 rounded text-xs" x-text="data.total + ' transfers'"></span>
                        </div>
                        <div class="space-y-1 text-sm">
                            <template x-for="route in data.routes.slice(0, 3)" :key="route.key">
                                <div class="flex justify-between text-gray-300">
                                    <span x-text="route.from + ' → ' + route.to"></span>
                                    <span class="text-gray-500" x-text="route.count"></span>
                                </div>
                            </template>
                            <template x-if="data.routes.length > 3">
                                <div class="text-blue-400 text-xs pt-1 flex items-center gap-1">
                                    <span>Click to see all <span x-text="data.routes.length"></span> routes</span>
                                    <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                                    </svg>
                                </div>
                            </template>
                        </div>
                    </div>
                </template>
            </div>
        </div>

        <!-- Buyline Detail Modal -->
        <div x-show="expandedBuyline !== null" x-cloak class="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4" @click.self="expandedBuyline = null">
            <div class="bg-gray-800 border border-gray-700 rounded-lg max-w-2xl w-full max-h-[80vh] overflow-hidden">
                <div class="p-6 border-b border-gray-700 flex justify-between items-center">
                    <div>
                        <h3 class="text-xl font-bold text-white" x-text="'All Routes for ' + expandedBuyline"></h3>
                        <p class="text-sm text-gray-400 mt-1" x-text="expandedBuyline && buylineData[expandedBuyline] ? buylineData[expandedBuyline].total + ' total transfers' : ''"></p>
                    </div>
                    <button @click="expandedBuyline = null" class="text-gray-400 hover:text-white">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
                <div class="p-6 overflow-y-auto max-h-[60vh]">
                    <template x-if="expandedBuyline && buylineData[expandedBuyline]">
                        <div class="space-y-2">
                            <template x-for="(route, index) in buylineData[expandedBuyline].routes" :key="route.key">
                                <div class="flex justify-between items-center p-3 bg-gray-900/50 rounded border border-gray-700">
                                    <div class="flex items-center gap-3">
                                        <span class="text-xs text-gray-500 font-mono w-6" x-text="(index + 1) + '.'"></span>
                                        <span class="text-white font-medium" x-text="route.from + ' → ' + route.to"></span>
                                    </div>
                                    <span class="px-3 py-1 bg-blue-600/20 border border-blue-500/30 text-blue-300 rounded text-sm font-semibold" x-text="route.count"></span>
                                </div>
                            </template>
                        </div>
                    </template>
                </div>
            </div>
        </div>

        <!-- Total Transfers by Route (All Buylines) -->
        <div class="bg-gray-800/50 border border-gray-700/50 rounded-lg p-6 mb-6">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-white">Total Transfers by Route</h2>
                <div class="flex items-center gap-3">
                    <label class="text-sm text-gray-400">Min Count:</label>
                    <input
                        type="number"
                        x-model.number="totalMinCount"
                        min="0"
                        placeholder="e.g., 100"
                        class="w-32 px-3 py-2 bg-gray-900 border border-gray-700 rounded-md text-white text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
                    >
                </div>
            </div>
            <p class="text-sm text-gray-400 mb-4">Aggregated transfers across all buylines, sorted by branch</p>
            <div class="overflow-x-auto">
                <table class="min-w-full text-sm">
                    <thead class="bg-gray-900/50 border-b border-gray-700">
                        <tr>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">From Branch</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">To Branch</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Transfer Count</th>
                        </tr>
                    </thead>
                    <tbody class="divide-y divide-gray-700">
                        <template x-for="(route, index) in totalTransfersData" :key="index">
                            <tr class="hover:bg-gray-700/30">
                                <td class="px-4 py-3 text-white font-medium" x-text="route.from"></td>
                                <td class="px-4 py-3 text-white font-medium" x-text="route.to"></td>
                                <td class="px-4 py-3 text-blue-300 font-semibold" x-text="route.count"></td>
                            </tr>
                        </template>
                        <template x-if="totalTransfersData.length === 0">
                            <tr>
                                <td colspan="3" class="px-4 py-8 text-center text-gray-500">
                                    No routes match the minimum count filter
                                </td>
                            </tr>
                        </template>
                    </tbody>
                </table>
            </div>
        </div>
        </div>

        <!-- Route Map Tab -->
        <div x-show="activeTab === 'map'" x-cloak>
            <div class="bg-gray-800/50 border border-gray-700/50 rounded-lg p-6 mb-6">
                <div class="flex justify-between items-center mb-4">
                    <div>
                        <h2 class="text-xl font-bold text-white">Transfer Route Map</h2>
                        <p class="text-sm text-gray-400 mt-1">Geographic visualization of branch-to-branch transfers</p>
                    </div>
                    <div class="flex items-center gap-3">
                        <label class="text-sm text-gray-400">Min Count:</label>
                        <input
                            type="number"
                            x-model.number="mapMinCount"
                            min="0"
                            @input="updateMap()"
                            placeholder="e.g., 100"
                            class="w-32 px-3 py-2 bg-gray-900 border border-gray-700 rounded-md text-white text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
                        >
                    </div>
                </div>

                <!-- Map Status/Loading -->
                <template x-if="!mapReady && activeTab === 'map'">
                    <div class="bg-gray-900/50 rounded-lg p-12 text-center border border-gray-700">
                        <div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mb-4"></div>
                        <p class="text-gray-400" x-text="mapStatus"></p>
                    </div>
                </template>

                <!-- Map Container -->
                <div x-show="mapReady" id="transferMap" class="rounded-lg overflow-hidden border border-gray-700" style="height: 600px;"></div>

                <!-- Map Legend -->
                <template x-if="mapReady">
                    <div class="mt-4 p-4 bg-gray-900/50 rounded border border-gray-700">
                        <h4 class="text-sm font-semibold text-white mb-2">Legend</h4>
                        <div class="grid grid-cols-2 md:grid-cols-4 gap-3 text-xs">
                            <div class="flex items-center gap-2">
                                <div class="w-8 h-1 bg-red-500"></div>
                                <span class="text-gray-400">High Volume (>1000)</span>
                            </div>
                            <div class="flex items-center gap-2">
                                <div class="w-8 h-1 bg-yellow-500"></div>
                                <span class="text-gray-400">Medium (100-1000)</span>
                            </div>
                            <div class="flex items-center gap-2">
                                <div class="w-8 h-1 bg-green-500"></div>
                                <span class="text-gray-400">Low (<100)</span>
                            </div>
                            <div class="flex items-center gap-2">
                                <div class="w-6 h-6 rounded-full bg-blue-500 border-2 border-white"></div>
                                <span class="text-gray-400">Branch Location</span>
                            </div>
                        </div>
                    </div>
                </template>
            </div>
        </div>

        <!-- Details Tab -->
        <div x-show="activeTab === 'details'">
            <!-- Filters -->
            <div class="bg-gray-800/50 border border-gray-700/50 rounded-lg p-4 mb-6">
            <div class="flex gap-4 items-end">
                <div class="flex-1">
                    <label class="block text-sm font-medium text-gray-400 mb-2">Filter by Buyline</label>
                    <select
                        x-model="selectedBuyline"
                        class="w-full px-4 py-2 bg-gray-900 border border-gray-700 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                    >
                        <option value="">All Buylines</option>
                        <template x-for="buyline in Object.keys(buylineData).sort()" :key="buyline">
                            <option :value="buyline" x-text="buyline"></option>
                        </template>
                    </select>
                </div>
                <div class="flex-1">
                    <label class="block text-sm font-medium text-gray-400 mb-2">Minimum Transfer Count</label>
                    <input
                        type="number"
                        x-model.number="minCount"
                        min="0"
                        placeholder="e.g., 100"
                        class="w-full px-4 py-2 bg-gray-900 border border-gray-700 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                    >
                </div>
                <div class="flex-1">
                    <label class="block text-sm font-medium text-gray-400 mb-2">Sort by</label>
                    <select
                        x-model="sortBy"
                        class="w-full px-4 py-2 bg-gray-900 border border-gray-700 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                    >
                        <option value="count-desc">Transfer Count (High to Low)</option>
                        <option value="count-asc">Transfer Count (Low to High)</option>
                        <option value="buyline">Buyline (A-Z)</option>
                        <option value="from">From Branch</option>
                        <option value="to">To Branch</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Interactive Table -->
        <div class="bg-gray-800/50 border border-gray-700/50 rounded-lg overflow-hidden mb-6">
            <div class="px-6 py-4 border-b border-gray-700">
                <h2 class="text-xl font-bold text-white">Transfer Routes</h2>
            </div>
            <div class="overflow-x-auto">
                <table class="w-full">
                    <thead class="bg-gray-900/50">
                        <tr>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Buyline</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">From Branch</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">To Branch</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Transfer Count</th>
                        </tr>
                    </thead>
                    <tbody class="divide-y divide-gray-700">
                        <template x-for="(row, index) in filteredAndSortedData" :key="index">
                            <tr class="hover:bg-gray-700/30 transition-colors">
                                <td class="px-6 py-4 text-sm font-medium text-white" x-text="row.buyline"></td>
                                <td class="px-6 py-4 text-sm text-gray-300" x-text="row.from"></td>
                                <td class="px-6 py-4 text-sm text-gray-300" x-text="row.to"></td>
                                <td class="px-6 py-4 text-sm text-blue-300 font-semibold" x-text="row.count"></td>
                            </tr>
                        </template>
                    </tbody>
                </table>
            </div>
        </div>
        </div>
    </div>
</div>

<!-- Include Papa Parse for CSV parsing -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

<!-- Include Chart.js for visualizations -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

<!-- Include SheetJS for Excel export -->
<script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>

<!-- Include Leaflet.js for mapping -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
function branchAnalysis() {
    return {
        dragOver: false,
        processing: false,
        dataLoaded: false,
        previewLoaded: false,
        filePreview: [],
        headerRow: 9,  // Default to row 9 (8 rows to skip)
        currentFile: null,
        rawData: [],
        buylineData: {},
        selectedBuyline: '',
        minCount: 100,  // Default minimum transfer count filter
        totalMinCount: 100,  // Default minimum for total transfers section
        sortBy: 'count-desc',
        expandedBuyline: null,
        topRoutesChart: null,
        buylineChart: null,
        activeTab: 'overview',  // Tab state
        mapReady: false,
        mapStatus: 'Initializing map...',
        mapMinCount: 100,
        mapInstance: null,
        branchCoordinates: {},  // Cache of branch coordinates
        mapMarkers: [],
        mapRoutes: [],

        init() {
            console.log('Branch Transfer Analysis initialized');

            // Watch for tab changes to map
            this.$watch('activeTab', (value) => {
                if (value === 'map' && !this.mapReady) {
                    this.$nextTick(() => {
                        this.initializeMap();
                    });
                }
            });
        },

        expandBuyline(buyline) {
            this.expandedBuyline = buyline;
        },

        get totalTransfersData() {
            // Aggregate all transfers by route (from → to) across all buylines
            const routeMap = {};

            Object.keys(this.buylineData).forEach(buyline => {
                this.buylineData[buyline].routes.forEach(route => {
                    const key = `${route.from}-${route.to}`;
                    if (!routeMap[key]) {
                        routeMap[key] = {
                            from: route.from,
                            to: route.to,
                            count: 0
                        };
                    }
                    routeMap[key].count += route.count;
                });
            });

            // Convert to array and filter by minimum count
            let data = Object.values(routeMap)
                .filter(route => !this.totalMinCount || route.count >= this.totalMinCount);

            // Sort by from branch, then to branch
            data.sort((a, b) => {
                const fromCompare = String(a.from).localeCompare(String(b.from), undefined, { numeric: true });
                if (fromCompare !== 0) return fromCompare;
                return String(a.to).localeCompare(String(b.to), undefined, { numeric: true });
            });

            return data;
        },

        handleDrop(event) {
            this.dragOver = false;
            const files = event.dataTransfer.files;
            if (files.length > 0) {
                this.loadPreview(files[0]);
            }
        },

        handleFileSelect(event) {
            const files = event.target.files;
            if (files.length > 0) {
                this.loadPreview(files[0]);
            }
        },

        loadPreview(file) {
            if (!file.name.endsWith('.csv')) {
                alert('Please select a CSV file');
                return;
            }

            this.processing = true;
            this.currentFile = file;

            // Parse CSV without header to get raw rows
            Papa.parse(file, {
                header: false,
                preview: 20,  // Only load first 20 rows for preview
                skipEmptyLines: false,
                complete: (results) => {
                    this.filePreview = results.data;
                    this.previewLoaded = true;
                    this.processing = false;
                },
                error: (error) => {
                    console.error('CSV parsing error:', error);
                    alert('Error parsing CSV file: ' + error.message);
                    this.processing = false;
                }
            });
        },

        cancelPreview() {
            this.previewLoaded = false;
            this.filePreview = [];
            this.currentFile = null;
            this.headerRow = 9;
        },

        processWithHeaderRow() {
            if (!this.currentFile) {
                alert('No file selected');
                return;
            }

            this.processing = true;
            this.processFile(this.currentFile);
        },

        processFile(file) {
            if (!file.name.endsWith('.csv')) {
                alert('Please select a CSV file');
                return;
            }

            this.processing = true;

            // Parse CSV as raw rows first
            Papa.parse(file, {
                header: false,
                skipEmptyLines: true,
                complete: (results) => {
                    const allRows = results.data;

                    // Check if we have enough rows
                    if (allRows.length < this.headerRow) {
                        alert(`File only has ${allRows.length} rows, but header row is set to ${this.headerRow}`);
                        this.processing = false;
                        return;
                    }

                    // Get header row (convert to 0-based index)
                    const headers = allRows[this.headerRow - 1];

                    // Get data rows (everything after header row)
                    const dataRows = allRows.slice(this.headerRow);

                    // Convert to array of objects using headers
                    this.rawData = dataRows
                        .filter(row => row.length > 0)  // Skip empty rows
                        .map(row => {
                            const obj = {};
                            headers.forEach((header, index) => {
                                obj[header] = row[index];
                            });
                            return obj;
                        });

                    console.log(`Processed ${this.rawData.length} rows with header row ${this.headerRow}`);

                    this.aggregateData();
                    this.dataLoaded = true;
                    this.previewLoaded = false;
                    this.processing = false;

                    // Wait for DOM to update then create charts
                    this.$nextTick(() => {
                        this.createCharts();
                    });
                },
                error: (error) => {
                    console.error('CSV parsing error:', error);
                    alert('Error parsing CSV file: ' + error.message);
                    this.processing = false;
                }
            });
        },

        aggregateData() {
            this.buylineData = {};

            this.rawData.forEach(row => {
                const buyline = row.BUYLINE;
                const from = row.XFER_FROM_BR;
                const to = row.XFER_TO_BR;

                if (!buyline || !from || !to) return;

                if (!this.buylineData[buyline]) {
                    this.buylineData[buyline] = {
                        total: 0,
                        routes: []
                    };
                }

                this.buylineData[buyline].total++;

                const routeKey = `${from}-${to}`;
                const existingRoute = this.buylineData[buyline].routes.find(r => r.key === routeKey);

                if (existingRoute) {
                    existingRoute.count++;
                } else {
                    this.buylineData[buyline].routes.push({
                        key: routeKey,
                        from: from,
                        to: to,
                        count: 1
                    });
                }
            });

            // Sort routes by count
            Object.keys(this.buylineData).forEach(buyline => {
                this.buylineData[buyline].routes.sort((a, b) => b.count - a.count);
            });
        },

        get filteredAndSortedData() {
            let data = [];

            Object.keys(this.buylineData).forEach(buyline => {
                if (this.selectedBuyline && buyline !== this.selectedBuyline) return;

                this.buylineData[buyline].routes.forEach(route => {
                    // Filter by minimum count
                    if (this.minCount && route.count < this.minCount) return;

                    data.push({
                        buyline: buyline,
                        from: route.from,
                        to: route.to,
                        count: route.count
                    });
                });
            });

            // Sort
            if (this.sortBy === 'count-desc') {
                data.sort((a, b) => b.count - a.count);
            } else if (this.sortBy === 'count-asc') {
                data.sort((a, b) => a.count - b.count);
            } else if (this.sortBy === 'buyline') {
                data.sort((a, b) => a.buyline.localeCompare(b.buyline));
            } else if (this.sortBy === 'from') {
                data.sort((a, b) => a.from - b.from);
            } else if (this.sortBy === 'to') {
                data.sort((a, b) => a.to - b.to);
            }

            return data;
        },

        createCharts() {
            // Top 10 Routes Chart
            const allRoutes = [];
            Object.keys(this.buylineData).forEach(buyline => {
                this.buylineData[buyline].routes.forEach(route => {
                    allRoutes.push({
                        label: `${buyline}: ${route.from} → ${route.to}`,
                        count: route.count
                    });
                });
            });
            allRoutes.sort((a, b) => b.count - a.count);
            const top10 = allRoutes.slice(0, 10);

            if (this.topRoutesChart) this.topRoutesChart.destroy();
            this.topRoutesChart = new Chart(this.$refs.topRoutesChart, {
                type: 'bar',
                data: {
                    labels: top10.map(r => r.label),
                    datasets: [{
                        label: 'Transfer Count',
                        data: top10.map(r => r.count),
                        backgroundColor: 'rgba(59, 130, 246, 0.8)',
                        borderColor: 'rgba(59, 130, 246, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    indexAxis: 'y',
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        x: {
                            ticks: { color: '#9CA3AF' },
                            grid: { color: '#374151' }
                        },
                        y: {
                            ticks: { color: '#9CA3AF' },
                            grid: { color: '#374151' }
                        }
                    }
                }
            });

            // Buyline Distribution Chart
            const buylines = Object.keys(this.buylineData).sort();
            const counts = buylines.map(b => this.buylineData[b].total);

            if (this.buylineChart) this.buylineChart.destroy();
            this.buylineChart = new Chart(this.$refs.buylineChart, {
                type: 'doughnut',
                data: {
                    labels: buylines,
                    datasets: [{
                        data: counts,
                        backgroundColor: [
                            'rgba(59, 130, 246, 0.8)',
                            'rgba(147, 51, 234, 0.8)',
                            'rgba(236, 72, 153, 0.8)',
                            'rgba(251, 146, 60, 0.8)',
                            'rgba(34, 197, 94, 0.8)',
                            'rgba(14, 165, 233, 0.8)',
                            'rgba(168, 85, 247, 0.8)',
                            'rgba(244, 63, 94, 0.8)',
                        ]
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: { color: '#9CA3AF' }
                        }
                    }
                }
            });
        },

        async initializeMap() {
            this.mapStatus = 'Fetching branch locations...';

            // Load cached coordinates from localStorage
            const cached = localStorage.getItem('branchCoordinates');
            if (cached) {
                this.branchCoordinates = JSON.parse(cached);
            }

            // Get unique branch numbers from data
            const branches = new Set();
            this.rawData.forEach(row => {
                if (row.XFER_FROM_BR) branches.add(row.XFER_FROM_BR);
                if (row.XFER_TO_BR) branches.add(row.XFER_TO_BR);
            });

            // Fetch coordinates for branches we don't have yet
            const branchArray = Array.from(branches);
            const missingBranches = branchArray.filter(b => !this.branchCoordinates[b]);

            if (missingBranches.length > 0) {
                this.mapStatus = `Geocoding ${missingBranches.length} branch locations...`;
                await this.fetchBranchCoordinates(missingBranches);
            }

            // Render the map
            this.renderMap();
        },

        async fetchBranchCoordinates(branchNumbers) {
            const results = {};

            for (let i = 0; i < branchNumbers.length; i++) {
                const branchNum = branchNumbers[i];
                this.mapStatus = `Geocoding branch ${branchNum} (${i + 1}/${branchNumbers.length})...`;

                try {
                    // Get branch data from Eclipse
                    const branchData = await this.getBranchData(branchNum);
                    if (!branchData || !branchData.branchEntityId) {
                        console.warn(`No branchEntityId for branch ${branchNum}`);
                        continue;
                    }

                    // Get customer address
                    const customerData = await this.getCustomerAddress(branchData.branchEntityId);
                    if (!customerData) {
                        console.warn(`No customer data for branch ${branchNum}`);
                        continue;
                    }

                    // Build address string
                    const addressParts = [
                        customerData.addressLine1,
                        customerData.city,
                        customerData.state,
                        customerData.zipcode || customerData.zip
                    ].filter(Boolean);

                    if (addressParts.length === 0) {
                        console.warn(`No address for branch ${branchNum}`);
                        continue;
                    }

                    const address = addressParts.join(', ');

                    // Geocode address
                    const coords = await this.geocodeAddress(address);
                    if (coords) {
                        results[branchNum] = {
                            ...coords,
                            address: address,
                            name: customerData.name || `Branch ${branchNum}`
                        };
                    }

                    // Rate limit: wait 1 second between requests to Nominatim
                    await new Promise(resolve => setTimeout(resolve, 1000));
                } catch (error) {
                    console.error(`Error geocoding branch ${branchNum}:`, error);
                }
            }

            // Merge with existing coordinates
            this.branchCoordinates = { ...this.branchCoordinates, ...results };

            // Cache in localStorage
            localStorage.setItem('branchCoordinates', JSON.stringify(this.branchCoordinates));
        },

        async getBranchData(branchNumber) {
            try {
                const response = await fetch(`/branch/api/branches/${branchNumber}/`, {
                    headers: {
                        'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]')?.value || ''
                    }
                });

                if (!response.ok) {
                    console.error(`Branch API error: ${response.status}`);
                    return null;
                }

                return await response.json();
            } catch (error) {
                console.error('Error fetching branch data:', error);
                return null;
            }
        },

        async getCustomerAddress(customerId) {
            try {
                const response = await fetch(`/branch/api/customers/${customerId}/`, {
                    headers: {
                        'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]')?.value || ''
                    }
                });

                if (!response.ok) {
                    console.error(`Customer API error: ${response.status}`);
                    return null;
                }

                return await response.json();
            } catch (error) {
                console.error('Error fetching customer data:', error);
                return null;
            }
        },

        async geocodeAddress(address) {
            try {
                // Use Django proxy to Nominatim (fixes CORS issues)
                const url = `/branch/api/geocode/?address=${encodeURIComponent(address)}`;
                const response = await fetch(url, {
                    headers: {
                        'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]')?.value || ''
                    }
                });

                if (!response.ok) {
                    const error = await response.json();
                    console.error(`Geocoding error: ${response.status}`, error);
                    return null;
                }

                const data = await response.json();
                return {
                    lat: data.lat,
                    lng: data.lng
                };
            } catch (error) {
                console.error('Geocoding error:', error);
                return null;
            }
        },

        renderMap() {
            this.mapStatus = 'Rendering map...';

            // Initialize Leaflet map
            const mapContainer = document.getElementById('transferMap');
            if (!mapContainer) {
                console.error('Map container not found');
                return;
            }

            // Clear existing map if any
            if (this.mapInstance) {
                this.mapInstance.remove();
            }

            this.mapInstance = L.map('transferMap').setView([39.8283, -98.5795], 4); // Center of US

            // Add tile layer (OpenStreetMap)
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                maxZoom: 18
            }).addTo(this.mapInstance);

            // Add branch markers
            const bounds = [];
            Object.keys(this.branchCoordinates).forEach(branchNum => {
                const branch = this.branchCoordinates[branchNum];
                const marker = L.circleMarker([branch.lat, branch.lng], {
                    radius: 8,
                    fillColor: '#3B82F6',
                    color: '#ffffff',
                    weight: 2,
                    opacity: 1,
                    fillOpacity: 0.8
                }).addTo(this.mapInstance);

                marker.bindPopup(`
                    <div class="text-sm">
                        <strong>Branch ${branchNum}</strong><br>
                        ${branch.name}<br>
                        <span class="text-gray-600">${branch.address}</span>
                    </div>
                `);

                this.mapMarkers.push(marker);
                bounds.push([branch.lat, branch.lng]);
            });

            // Fit map to show all branches
            if (bounds.length > 0) {
                this.mapInstance.fitBounds(bounds, { padding: [50, 50] });
            }

            // Draw routes
            this.updateMap();

            this.mapReady = true;
            this.mapStatus = '';
        },

        updateMap() {
            if (!this.mapInstance) return;

            // Clear existing routes
            this.mapRoutes.forEach(route => route.remove());
            this.mapRoutes = [];

            // Get routes from totalTransfersData with min count filter
            const routes = this.totalTransfersData.filter(route =>
                !this.mapMinCount || route.count >= this.mapMinCount
            );

            // Draw routes
            routes.forEach(route => {
                const fromCoords = this.branchCoordinates[route.from];
                const toCoords = this.branchCoordinates[route.to];

                if (!fromCoords || !toCoords) return;

                // Calculate line thickness based on transfer count
                const weight = Math.max(2, Math.min(12, Math.log(route.count + 1) * 2));

                // Color based on volume
                let color = '#10B981'; // green (low)
                if (route.count > 1000) color = '#EF4444'; // red (high)
                else if (route.count > 100) color = '#F59E0B'; // yellow (medium)

                const polyline = L.polyline([
                    [fromCoords.lat, fromCoords.lng],
                    [toCoords.lat, toCoords.lng]
                ], {
                    color: color,
                    weight: weight,
                    opacity: 0.6
                }).addTo(this.mapInstance);

                polyline.bindPopup(`
                    <div class="text-sm">
                        <strong>Branch ${route.from} → ${route.to}</strong><br>
                        ${route.count.toLocaleString()} transfers
                    </div>
                `);

                this.mapRoutes.push(polyline);
            });
        },

        downloadCSV() {
            const data = this.filteredAndSortedData;
            const csv = Papa.unparse(data);
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'branch_transfer_analysis.csv';
            a.click();
            window.URL.revokeObjectURL(url);
        },

        downloadExcel() {
            const wb = XLSX.utils.book_new();

            // Summary sheet
            const summaryData = Object.keys(this.buylineData).map(buyline => ({
                Buyline: buyline,
                'Total Transfers': this.buylineData[buyline].total,
                'Unique Routes': this.buylineData[buyline].routes.length
            }));
            const summarySheet = XLSX.utils.json_to_sheet(summaryData);
            XLSX.utils.book_append_sheet(wb, summarySheet, 'Summary');

            // Details sheet
            const detailsSheet = XLSX.utils.json_to_sheet(this.filteredAndSortedData);
            XLSX.utils.book_append_sheet(wb, detailsSheet, 'Transfer Details');

            // By Buyline sheets (top 5 buylines)
            const topBuylines = Object.keys(this.buylineData)
                .sort((a, b) => this.buylineData[b].total - this.buylineData[a].total)
                .slice(0, 5);

            topBuylines.forEach(buyline => {
                const buylineRoutes = this.buylineData[buyline].routes.map(r => ({
                    'From Branch': r.from,
                    'To Branch': r.to,
                    'Transfer Count': r.count
                }));
                const sheet = XLSX.utils.json_to_sheet(buylineRoutes);
                XLSX.utils.book_append_sheet(wb, sheet, buyline.substring(0, 31)); // Excel sheet name limit
            });

            XLSX.writeFile(wb, 'branch_transfer_analysis.xlsx');
        },

        resetData() {
            this.dataLoaded = false;
            this.previewLoaded = false;
            this.filePreview = [];
            this.currentFile = null;
            this.headerRow = 9;
            this.rawData = [];
            this.buylineData = {};
            this.selectedBuyline = '';
            this.minCount = 100;
            this.totalMinCount = 100;
            this.expandedBuyline = null;
            this.sortBy = 'count-desc';
            this.activeTab = 'overview';
            this.mapReady = false;
            this.mapMinCount = 100;
            if (this.topRoutesChart) this.topRoutesChart.destroy();
            if (this.buylineChart) this.buylineChart.destroy();
            if (this.mapInstance) {
                this.mapInstance.remove();
                this.mapInstance = null;
            }
            this.mapMarkers = [];
            this.mapRoutes = [];
            // Note: We keep branchCoordinates cached for reuse
        }
    };
}
</script>
{% endblock %}
